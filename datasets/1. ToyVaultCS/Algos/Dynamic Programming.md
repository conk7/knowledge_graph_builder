Динамическое программирование — не конкретный алгоритм, а парадигма решения задач, основанная на двух фундаментальных идеях: оптимальной подструктуре и перекрывающихся подзадачах. Ричард Беллман, введший термин в 1950-х, описывал его как «искусство превращать экспоненциальный перебор в полиномиальный за счёт памяти».

## Признаки задачи, подходящей под DP
1. Оптимальная подструктура: оптимальное решение задачи содержит оптимальные решения подзадач
2. Перекрывающиеся подзадачи: одни и те же подзадачи решаются многократно
3. Возможность определить состояние и переход

Если хотя бы один пункт отсутствует — классическое DP, скорее всего, не применимо.

## Два основных подхода
- Bottom-up: заполняем таблицу от меньших подзадач к большим (чаще используется в соревнованиях)
- Top-down с мемоизацией: рекурсия + кэширование (естественнее для понимания)

## Классификация состояний
- По префиксам/суффиксам последовательности (LCS, LIS)
- По интервалам (матричное умножение, палиндромное разбиение)
- По битмаскам (TSP, задачи на подмножествах)
- По дереву/графу (независимое множество, дерево с рюкзаком)

## Канонические примеры и их уроки
- [[Fibonacci]] — простейший пример перекрывающихся подзадач
- [[Knapsack 0-1]] — введение второго измерения состояния
- [[Longest Common Subsequence]] — двумерная таблица и восстановление ответа
- [[Traveling Salesman Problem]] (битмаски) — экспоненциальное по числу вершин, но полиномиальное по 2^n
- [[Matrix Chain Multiplication]] — оптимизация скобок и интервальное DP

## Современные вариации и оптимизации
- Knuth optimization (выпуклая оболочка квадратичных функций)
- Divide & Conquer optimization (делимость переходов)
- Alien trick (состояние как время + хитрая монотонность)
- SOS DP (быстрое вычисление сумм по подмаскам)

## Практические рекомендации
1. Сначала решите задачу жадным алгоритмом — поймёте, где он ломается
2. Определите минимальное состояние: dp[i][j] должно однозначно определять ответ для префикса
3. Проверьте возможность сжатия размерности (часто можно хранить только два последних слоя)
4. Всегда думайте о восстановлении ответа (parent pointers или рекурсивный вывод)

## Философское значение
Динамическое программирование учит одному из главных уроков алгоритмики: иногда платить памятью за время — не просто допустимо, а единственно разумно. Многие задачи, кажущиеся неразрешимыми из-за экспоненциальной сложности, после правильного определения состояния оказываются вполне решаемыми.

См. также: [[Memoization]], [[Knapsack Problem]], [[Longest Increasing Subsequence]], [[Bitmask DP]], [[Knuth Optimization]], [[Divide and Conquer Optimization]]