Бинарный поиск — возможно, самый элегантный пример принципа «разделяй и властвуй». За десятилетия он стал эталоном эффективности при работе с упорядоченными данными.

## Предпосылки и ограничения
Алгоритм требует монотонности целевой функции или предварительно отсортированного массива. Нарушение этого условия превращает O(log n) в неопределённое поведение.

## Вариации и обобщения
- Классический поиск элемента
- [[Lower Bound]] — первая позиция ≥ x
- [[Upper Bound]] — первая позиция > x
- [[Бинарный поиск по ответу]] — мощная техника решения оптимизационных задач
- Поиск экстремума унимодальной функции

## Теоретическая красота
Каждый шаг уменьшает пространство поиска ровно вдвое. Это даёт точную оценку log₂ n ± 1 сравнений — одну из немногих задач, где теоретическая граница достигается на практике.

## Реализация без подводных камней
```python
def binary_search(arr, target):
    lo, hi = 0, len(arr) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            lo = mid + 1
        else:
            hi = mid - 1
    return -1
````

Особое внимание стоит уделить переполнению при вычислении mid в языках с фиксированной арифметикой:

```python
mid = lo + (hi - lo) // 2   # безопасный вариант
```

Место в современном программированииНесмотря на простоту, бинарный поиск продолжает находить применение:

- std::lower_bound / upper_bound в C++
- bisect в Python
- Поиск в отсортированных структурах данных (TreeMap, OrderedSet)
- Решение задач на Codeforces и LeetCode уровня Hard

Мастерство владения бинарным поиском по ответу часто отличает сильного конкурента от среднего.

См. также: [[Lower Bound]], [[Бинарный поиск по ответу]], [[Тернальный поиск]], [[Peak Finding]]