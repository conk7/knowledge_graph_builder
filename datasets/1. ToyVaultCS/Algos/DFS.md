Поиск в глубину — алгоритм, который следует по каждому возможному пути до конца, прежде чем отступить. Его рекурсивная природа делает его естественным инструментом для исследования структуры графов.

## Философия глубины
В отличие от [[BFS]], который распространяется равномерно, DFS погружается максимально глубоко. Это делает его идеальным для задач, где решение может лежать в глубине дерева поиска.

## Основные применения
- [[Топологическая сортировка]] в DAG
- Поиск компонент сильной связности (алгоритмы Косарайю и Тарьяна)
- Обнаружение циклов
- Решение головоломок и лабиринтов
- [[Backtracking]] — естественное продолжение DFS

## Временные метки и классификация рёбер
Классический DFS позволяет ввести:
- discovery time и finishing time
- Древесные, прямые, обратные и поперечные рёбра
Эти метки лежат в основе многих продвинутых алгоритмов.

## Реализация и стек
```python
def dfs_iterative(start):
    stack = [start]
    visited = set()
    
    while stack:
        vertex = stack.pop()
        if vertex in visited:
            continue
        visited.add(vertex)
        for neighbour in reversed(graph[vertex]):  # важен порядок
            if neighbour not in visited:
                stack.append(neighbour)
````

Рекурсивная версия лаконичнее, но ограничена глубиной стека.

## Преимущества и ограничения

Преимущества:

- Минимальное использование памяти O(h) в дереве
- Быстрое нахождение решения, если оно близко по глубине
- Естественная реализация backtracking

Ограничения:

- Неоптимален по длине пути
- Может застрять в бесконечной ветке без ограничения глубины

Современное значениеDFS остаётся основой для:

- Построения остовных деревьев
- Планирования в ИИ (поиск в пространстве состояний)
- Анализа потока управления в компиляторах
- Решения NP-полных задач перебором с отсечением

В некоторых задачах (например, поиск артикуляционных точек) DFS не имеет разумных альтернатив.

См. также: [[BFS]], [[Backtracking]], [[Топологическая сортировка]], [[Косарайю]], [[Тарьяна алгоритм]]